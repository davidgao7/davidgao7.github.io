<!doctype html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <title>TCP Rust // davidgao7 blog</title>
    <link rel="shortcut icon" href="/images/favicon.jpg" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.147.2">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="David Gao" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.5b1fcc8902588589c4767187402a3c29f8b8d7a6fdef6d9f8f77045bb0d14fee.css" />
    

    
    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="TCP Rust">
  <meta name="twitter:description" content="TCPImplementation video Project Goal Learn how to write rust Learn how to implement TCP protocal Implement TCP in Rust
TCP-rust-issue-face-and-fixing For this page, I will take notes on tcp concepts
Getting the basics 1. Three-Way Handshake (Connection Establishment) The TCP connection starts with the SYN → SYN-ACK → ACK process.
Client Server | | | ---------- SYN ----------&gt; | (Client requests connection) | | | &lt;-------- SYN-ACK -------- | (Server acknowledges) | | | ---------- ACK ----------&gt; | (Client confirms connection) | | Connection Established! SYN: Client sends a connection request to the server. SYN-ACK: Server acknowledges the request and sends its own connection request. ACK: Client acknowledges the server’s response. 2. Data Transmission Once the connection is established, data flows in both directions with sequence numbers and acknowledgments.">

    <meta property="og:url" content="http://localhost:1313/posts/tcp-rust/">
  <meta property="og:site_name" content="davidgao7 blog">
  <meta property="og:title" content="TCP Rust">
  <meta property="og:description" content="TCPImplementation video Project Goal Learn how to write rust Learn how to implement TCP protocal Implement TCP in Rust
TCP-rust-issue-face-and-fixing For this page, I will take notes on tcp concepts
Getting the basics 1. Three-Way Handshake (Connection Establishment) The TCP connection starts with the SYN → SYN-ACK → ACK process.
Client Server | | | ---------- SYN ----------&gt; | (Client requests connection) | | | &lt;-------- SYN-ACK -------- | (Server acknowledges) | | | ---------- ACK ----------&gt; | (Client confirms connection) | | Connection Established! SYN: Client sends a connection request to the server. SYN-ACK: Server acknowledges the request and sends its own connection request. ACK: Client acknowledges the server’s response. 2. Data Transmission Once the connection is established, data flows in both directions with sequence numbers and acknowledgments.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-07T22:35:50-05:00">
    <meta property="article:modified_time" content="2025-02-07T22:35:50-05:00">
    <meta property="article:tag" content="Tcp">
    <meta property="article:tag" content="Rust">
    <meta property="article:tag" content="Network">


    
      <script>
window.MathJax = {
  tex: {
    inlineMath: [['\\(', '\\)']],
    displayMath: [['\\[', '\\]'], ['$$', '$$']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js">
</script>


    

  </head>
  <body>
    <header class="app-header">
      <a href="/"><img class="app-header-avatar" src="/images/avatar.jpg" alt="David Gao" /></a>
      <span class="app-header-title">davidgao7 blog</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">Home</a>
             - 
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>Note new findings every day to let the magic happen!</p>
      <div class="app-header-social">
        
          <a href="https://github.com/davidgao7" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-github" viewBox="0 0 24 24" fill="currentColor"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
          </a>
        
          <a href="https://x.com/AiiGen71976j" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-x" viewBox="0 0 24 24" fill="currentColor"><title>X</title><path d="M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"/></svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">TCP Rust</h1>
      <div class="post-meta">
        <div>
          <svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
          Feb 7, 2025
        </div>
        <div>
          <svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
          18 min read
        </div>
        <div>
          <svg class="icon icon-tag" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg>
              <a class="tag" href="/tags/tcp/">Tcp</a>
              <a class="tag" href="/tags/rust/">Rust</a>
              <a class="tag" href="/tags/network/">Network</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="tcpimplementation">TCPImplementation</h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=bzja9fQWzdA&amp;list=PLqbS7AVVErFivDY3iKAQk3_VAm8SXwt1X&amp;index=2&amp;t=206s">video</a></li>
</ul>
<h2 id="project-goal">Project Goal</h2>
<ul>
<li>Learn how to write rust</li>
<li>Learn how to implement TCP protocal</li>
</ul>
<blockquote>
<p>Implement TCP in Rust</p></blockquote>
<ul>
<li><a href="/personalProjects/TCP-rust-issue-face-and-fixing.md">TCP-rust-issue-face-and-fixing</a></li>
</ul>
<p>For this page, I will take notes on tcp concepts</p>
<h2 id="getting-the-basics">Getting the basics</h2>
<hr>
<h3 id="1-three-way-handshake-connection-establishment"><strong>1. Three-Way Handshake (Connection Establishment)</strong></h3>
<p>The TCP connection starts with the <strong>SYN → SYN-ACK → ACK</strong> process.</p>
<pre tabindex="0"><code class="language-ascii" data-lang="ascii">Client                               Server
   |                                   |
   | ---------- SYN ----------&gt;        |  (Client requests connection)
   |                                   |
   | &lt;-------- SYN-ACK --------        |  (Server acknowledges)
   |                                   |
   | ---------- ACK ----------&gt;        |  (Client confirms connection)
   |                                   |
Connection Established!
</code></pre><ul>
<li><strong>SYN</strong>: Client sends a connection request to the server.</li>
<li><strong>SYN-ACK</strong>: Server acknowledges the request and sends its own connection request.</li>
<li><strong>ACK</strong>: Client acknowledges the server&rsquo;s response.</li>
</ul>
<hr>
<h3 id="2-data-transmission"><strong>2. Data Transmission</strong></h3>
<p>Once the connection is established, data flows in both directions with sequence numbers and acknowledgments.</p>
<pre tabindex="0"><code class="language-ascii" data-lang="ascii">Client                               Server
   |                                   |
   | ------ DATA [SEQ=1] ------&gt;       |  (Send data with sequence number 1)
   | &lt;--- ACK [SEQ=2, ACK=2] ----      |  (Server acknowledges receipt)
   |                                   |
   | &lt;------ DATA [SEQ=2] ------       |  (Server sends data back)
   | ------ ACK [SEQ=3, ACK=3] --&gt;     |  (Client acknowledges receipt)
   |                                   |
</code></pre><ul>
<li><strong>SEQ</strong>: Sequence number identifies the position of the data.</li>
<li><strong>ACK</strong>: Acknowledgment ensures the previous data was received.</li>
</ul>
<p>TCP guarantees <strong>reliability</strong> through:</p>
<ol>
<li><strong>Sequence Numbers</strong>: To order packets.</li>
<li><strong>Acknowledgments</strong>: To confirm delivery.</li>
<li><strong>Retransmission</strong>: If a packet is lost.</li>
</ol>
<hr>
<h3 id="3-connection-termination-four-way-handshake"><strong>3. Connection Termination (Four-Way Handshake)</strong></h3>
<p>To close the connection, TCP uses a <strong>FIN → ACK → FIN → ACK</strong> sequence.</p>
<pre tabindex="0"><code class="language-ascii" data-lang="ascii">Client                               Server
   |                                   |
   | -------- FIN --------&gt;            |  (Client wants to close connection)
   | &lt;-------- ACK --------            |  (Server acknowledges FIN)
   |                                   |
   | &lt;-------- FIN --------            |  (Server closes connection)
   | -------- ACK --------&gt;            |  (Client acknowledges FIN)
   |                                   |
Connection Closed!
</code></pre><ul>
<li><strong>FIN</strong>: A &ldquo;finish&rdquo; flag to indicate one side is done sending data.</li>
<li><strong>ACK</strong>: Acknowledge the connection is closing.</li>
</ul>
<hr>
<h3 id="overall-summary"><strong>Overall Summary</strong></h3>
<pre tabindex="0"><code class="language-ascii" data-lang="ascii">  Connection Start: Three-Way Handshake
  -------------------------------------
  SYN -&gt; SYN-ACK -&gt; ACK

  Data Transmission: Reliable Data Flow
  -------------------------------------
  DATA [SEQ] -&gt; ACK [SEQ]
  (Ensures order, error checking, and retransmission)

  Connection End: Four-Way Handshake
  ----------------------------------
  FIN -&gt; ACK -&gt; FIN -&gt; ACK
</code></pre><hr>
<p>This is a simplified version of TCP to help you visualize how it works step by step. Each step ensures a <strong>reliable connection</strong> with ordered data delivery, acknowledgments, and connection closure.</p>
<h2 id="code">Code</h2>
<ul>
<li>package used
<ul>
<li>linux <a href="https://www.kernel.org/doc/Documentation/networking/tuntap.txt"> tuntap </a></li>
</ul>
</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.ietf.org/rfc/rfc791.txt">rfc 791 Internet Protocal</a></li>
</ul>
<pre tabindex="0"><code class="language-ascii" data-lang="ascii">3.1.  Internet Header Format

  A summary of the contents of the internet header follows:

                                    
    0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    Example Internet Datagram Header

                               Figure 4.

  Note that each tick mark represents one bit position.

  Version:  4 bits

    The Version field indicates the format of the internet header.  This
    document describes version 4.

  IHL:  4 bits

    Internet Header Length is the length of the internet header in 32
    bit words, and thus points to the beginning of the data.  Note that
    the minimum value for a correct header is 5.
</code></pre><h2 id="what-is-a-tun-interface">What is a TUN Interface</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> nic <span style="color:#f92672">=</span> tun_tap::Iface::new(<span style="color:#e6db74">&#34;tun0&#34;</span>, tun_tap::Mode::Tun)<span style="color:#f92672">?</span>;
</span></span></code></pre></div><ul>
<li>a <code>TUN interface</code> is a virtual network device that operates at the IP level(layer 3)</li>
<li>it is used for <strong>packet routing</strong> and is often employed for VPNs, network simulations, or custom routing logic</li>
</ul>
<h3 id="receiving-data">receiving data</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> nbytes <span style="color:#f92672">=</span> nic.recv(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buf[<span style="color:#f92672">..</span>])<span style="color:#f92672">?</span>;
</span></span></code></pre></div><ul>
<li>
<p>need to grant capabilities to executable files.</p>
</li>
<li>
<p>linix command: <code>setcap</code></p>
</li>
<li>
<p>create a <code>ip</code></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> tun_tap;  <span style="color:#75715e">// Declares the use of the tun_tap crate, which provides bindings for creating and managing TUN/TAP interfaces.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> hex; <span style="color:#75715e">// hexdecimal encoding/decoding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::io;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> hex_fmt::HexFmt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// see if tun_tap working
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    * Ok(()) : Success
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    * Err(io::Error) : an error from the standard I/O library
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    * */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">print!</span>(<span style="color:#e6db74">&#34;======run till here 0=============</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// create a TUN interface
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// network interface name: `tun0`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// `tun_tap::Mode::Tun`: specifies that this is a **TUN interface** (layer 3 - IP packets)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> nic <span style="color:#f92672">=</span> tun_tap::Iface::new(<span style="color:#e6db74">&#34;tun0&#34;</span>, tun_tap::Mode::Tun)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">print!</span>(<span style="color:#e6db74">&#34;======run till here 1=============</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// create a new interface
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// this buffer will hold the incoming packet data from the TUN interface
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buf <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span><span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">1504</span>]; <span style="color:#75715e">// create a buffer of size 1504 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">print!</span>(<span style="color:#e6db74">&#34;======run till here 2=============</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// receiving data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// this is a **blocking operation**, the program will wait until a packet is received
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> nbytes <span style="color:#f92672">=</span> nic.recv(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buf[<span style="color:#f92672">..</span>])<span style="color:#f92672">?</span>;  <span style="color:#75715e">// Receives a packet from the interface, return #bytes copied into the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">print!</span>(<span style="color:#e6db74">&#34;======run till here 3=============</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// nbytes: the number of bytes read into buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// &amp;buf[..nbytes] : a slice of the buffer containing only the received data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// {:x} : attempts to format the buffer slice as hexadecimal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">print!</span>(<span style="color:#e6db74">&#34;======run till here 4=============</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">eprintln!</span>(<span style="color:#e6db74">&#34;read </span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> bytes: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, nbytes, HexFmt(<span style="color:#f92672">&amp;</span>buf[<span style="color:#f92672">..</span>nbytes]));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Ok(()) <span style="color:#75715e">// success
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>run Rust program</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cargo r --release
</span></span></code></pre></div><p>we will get this output</p>
<pre tabindex="0"><code>root@61cbf190478a:/home/developer/tcp_implementation# cargo r --release
    Finished `release` profile [optimized] target(s) in 0.12s
     Running `target/release/tcp_implementation`
^@^@
</code></pre><p>execute the excutable</p>
<p>get perminssion for the excutatble</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>setcap cap_net_admin<span style="color:#f92672">=</span>eip target/release/tcp_implementation
</span></span></code></pre></div><p>check the ip address</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ip addr
</span></span></code></pre></div><pre tabindex="0"><code>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/ipip 0.0.0.0 brd 0.0.0.0
3: gre0@NONE: &lt;NOARP&gt; mtu 1476 qdisc noop state DOWN group default qlen 1000
    link/gre 0.0.0.0 brd 0.0.0.0
4: gretap0@NONE: &lt;BROADCAST,MULTICAST&gt; mtu 1462 qdisc noop state DOWN group default qlen 1000
    link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff
5: erspan0@NONE: &lt;BROADCAST,MULTICAST&gt; mtu 1450 qdisc noop state DOWN group default qlen 1000
    link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff
6: ip_vti0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/ipip 0.0.0.0 brd 0.0.0.0
7: ip6_vti0@NONE: &lt;NOARP&gt; mtu 1332 qdisc noop state DOWN group default qlen 1000
    link/tunnel6 :: brd :: permaddr 3e76:a20:6dc::
8: sit0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/sit 0.0.0.0 brd 0.0.0.0
9: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1000
    link/tunnel6 :: brd :: permaddr 56e3:7e5a:1fcb::
10: ip6gre0@NONE: &lt;NOARP&gt; mtu 1448 qdisc noop state DOWN group default qlen 1000
    link/gre6 :: brd :: permaddr 1256:ba4f:67ba::
20: tun0: &lt;POINTOPOINT,MULTICAST,NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 500
    link/none
22: eth0@if23: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:15:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.21.0.2/16 brd 172.21.255.255 scope global eth0
       valid_lft forever preferred_lft forever
</code></pre><ul>
<li>notice there is one called <code>tun0</code> which created by us</li>
</ul>
<p>Then we use the following commands:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ip addr add 192.168.0.1/24 dev tun0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ip link set up dev tun0  <span style="color:#75715e"># notice this line</span>
</span></span></code></pre></div><p>whenever we execute this line, our rust program(which running also) will run main</p>
<pre tabindex="0"><code>root@61cbf190478a:/home/developer/tcp_implementation# target/release/tcp_implementation
======run till here 0=============
======run till here 1=============
======run till here 2=============
======run till here 3=============
======run till here 4=============
read 52 bytes: 000086dd6000000000083afffe80000000000000707e1f5329cf04abff0200000000000000000000000000028500beeb00000000
</code></pre><p>we are getting the hexdecimal, lets split it into arr:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#a6e22e">eprintln!</span>(<span style="color:#e6db74">&#34;read </span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> bytes: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, nbytes, HexFmt(<span style="color:#f92672">&amp;</span>buf[<span style="color:#f92672">..</span>nbytes]));
</span></span></code></pre></div><p>change to</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#a6e22e">eprintln!</span>(<span style="color:#e6db74">&#34;read </span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> bytes: </span><span style="color:#e6db74">{:02x?}</span><span style="color:#e6db74">&#34;</span>, nbytes, <span style="color:#f92672">&amp;</span>buf[<span style="color:#f92672">..</span>nbytes]);
</span></span></code></pre></div><p>Lets also create a <code>run.sh</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1. build the rust project</span>
</span></span><span style="display:flex;"><span>cargo b --release
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. add executable permission (no need as I&#39;m root)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># setcap cap_net_admin=eip ../target/release/tcp_implementation</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. run rust executable in background</span>
</span></span><span style="display:flex;"><span>../target/release/tcp_implementation &amp;
</span></span><span style="display:flex;"><span>pid<span style="color:#f92672">=</span>$! <span style="color:#75715e"># create a thread to wait response</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. add tun0 ip addr</span>
</span></span><span style="display:flex;"><span>ip addr add 192.168.0.1/24 dev tun0
</span></span><span style="display:flex;"><span>ip link set up dev tun0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 5. check ip addr</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ip addr</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># wait process to finish</span>
</span></span><span style="display:flex;"><span>wait $pid
</span></span></code></pre></div><p>we see the bytes:</p>
<pre tabindex="0"><code>read 52 bytes: [00, 00, 86, dd, 60, 00, 00, 00, 00, 08, 3a, ff, fe, 80, 00, 00, 00, 00, 00, 00, af, ef, b2, 6a, 91, 4b, 1b, ed, ff, 02, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 02, 85, 00, 6d, a4, 00, 00, 00, 00]
</code></pre><p>but we don&rsquo;t know what exactly they are, so let&rsquo;s try to interpret them</p>
<ul>
<li>package use: <code>tshark</code></li>
</ul>
<p>create a infinite loop to keep recieving data</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#75715e">// receiving data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// this is a **blocking operation**, the program will wait until a packet is received
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">loop</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> nbytes <span style="color:#f92672">=</span> nic.recv(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buf[<span style="color:#f92672">..</span>])<span style="color:#f92672">?</span>;  <span style="color:#75715e">// Receives a packet from the interface, return #bytes copied into the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//print!(&#34;======run till here 3=============\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// nbytes: the number of bytes read into buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// &amp;buf[..nbytes] : a slice of the buffer containing only the received data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// {:x} : attempts to format the buffer slice as hexadecimal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//print!(&#34;======run till here 4=============\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">eprintln!</span>(<span style="color:#e6db74">&#34;read </span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> bytes: </span><span style="color:#e6db74">{:02x?}</span><span style="color:#e6db74">&#34;</span>, nbytes, <span style="color:#f92672">&amp;</span>buf[<span style="color:#f92672">..</span>nbytes]);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>if we first <code>ping</code> the <code>tun0</code> with a address, we will get continuing packet recieved</p>
<ol>
<li>run the rust program with the shell script we created</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sh run.sh
</span></span></code></pre></div><ol start="2">
<li>ping the <code>tun0</code> we created with a ip address</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>ping -I tun0 192.168.0.2
</span></span></code></pre></div><p>we will get continue packets received</p>
<pre tabindex="0"><code>root@61cbf190478a:/home/developer/tcp_implementation/src# read 52 bytes: [00, 00, 86, dd, 60, 00, 00, 00, 00, 08, 3a, ff, fe, 80, 00, 00, 00, 00, 00, 00, 33, 83, 88, 94, bd, 02, be, f2, ff, 02, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 02, 85, 00, 45, 2a, 00, 00, 00, 00]
read 88 bytes: [00, 00, 08, 00, 45, 00, 00, 54, 27, 0d, 40, 00, 40, 01, 92, 48, c0, a8, 00, 01, c0, a8, 00, 02, 08, 00, 85, dd, 00, 01, 00, 01, e1, 01, 66, 67, 00, 00, 00, 00, 6b, e4, 00, 00, 00, 00, 00, 00, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1a, 1b, 1c, 1d, 1e, 1f, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 2a, 2b, 2c, 2d, 2e, 2f, 30, 31, 32, 33, 34, 35, 36, 37]
read 88 bytes: [00, 00, 08, 00, 45, 00, 00, 54, 28, 5c, 40, 00, 40, 01, 90, f9, c0, a8, 00, 01, c0, a8, 00, 02, 08, 00, 41, db, 00, 01, 00, 02, e2, 01, 66, 67, 00, 00, 00, 00, ad, e5, 01, 00, 00, 00, 00, 00, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1a, 1b, 1c, 1d, 1e, 1f, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 2a, 2b, 2c, 2d, 2e, 2f, 30, 31, 32, 33, 34, 35, 36, 37]
read 88 bytes: [00, 00, 08, 00, 45, 00, 00, 54, 29, f3, 40, 00, 40, 01, 8f, 62, c0, a8, 00, 01, c0, a8, 00, 02, 08, 00, 65, 7c, 00, 01, 00, 03, e3, 01, 66, 67, 00, 00, 00, 00, 88, 43, 02, 00, 00, 00, 00, 00, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1a, 1b, 1c, 1d, 1e, 1f, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 2a, 2b, 2c, 2d, 2e, 2f, 30, 31, 32, 33, 34, 35, 36, 37]
</code></pre><p>video timestamp: Implementing TCP in Rust 31:02, Jon Gjengset</p>
<h1 id="issue-face-and-fixing">Issue face and fixing</h1>
<p><a href="/personalProjects/TCP-rust-issue-face-and-fixing.md">Issue face and fixing</a></p>
<p>functions learning:</p>
<p>The <code>u16::from_be_bytes()</code> function in Rust constructs a <code>u16</code> integer from a 2-element byte array interpreted in big-endian (network) byte order. This means the most significant byte is at the first position of the array.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>bytes</code>: A <code>[u8; 2]</code> array representing the bytes in big-endian order.</li>
</ul>
<p><strong>Output:</strong></p>
<ul>
<li>Returns a <code>u16</code> integer composed from the provided byte array.</li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> byte_array: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0x12</span>, <span style="color:#ae81ff">0x34</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> number <span style="color:#f92672">=</span> <span style="color:#66d9ef">u16</span>::from_be_bytes(byte_array);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;The number is: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, number);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Output: The number is: 4660
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>Explanation:</strong>
In this example, the byte array <code>[0x12, 0x34]</code> is interpreted as the hexadecimal number <code>0x1234</code>, which equals <code>4660</code> in decimal. The <code>u16::from_be_bytes()</code> function correctly assembles these bytes into the <code>u16</code> integer <code>4660</code>.</p>
<p>This function is particularly useful when dealing with data from network protocols or file formats that use big-endian byte ordering. It ensures that the byte sequence is interpreted correctly as a <code>u16</code> value on any platform.</p>
<p><a href="https://doc.rust-lang.org/std/primitive.u16.html"> For more details, refer to the official Rust documentation </a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pgrep -af target
</span></span></code></pre></div><p>ex. Output</p>
<pre tabindex="0"><code>root@61cbf190478a:/home/developer/tcp_implementation/src# pgrep -af target
5153 ../target/release/tcp_implementation
</code></pre><p>is used to search for processes whose name or arguments match the string <code>target</code> and display detailed information about them.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pgrep -af &lt;pattern&gt;
</span></span></code></pre></div><h3 id="what-it-does">What It Does:</h3>
<ol>
<li>Searches for processes where the full command line contains the specified <code>pattern</code> (in this case, &ldquo;target&rdquo;).</li>
<li>Prints the process IDs (PIDs) and their full command lines for all matching processes.</li>
</ol>
<p>we run <code>run.sh</code>, we get</p>
<pre tabindex="0"><code>read 48 bytes (flags: 0, proto: 86dd: [60, 0, 0, 0, 0, 8, 3a, ff, fe, 80, 0, 0, 0, 0, 0, 0, 64, 35, cb, f9, 8f, e3, aa, 94, ff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 85, 0, 12, 90, 0, 0, 0, 0])
</code></pre><p>so, what does protocal number <code>86dd</code> do:</p>
<blockquote>
<p>The hexadecimal value 0x86DD is the EtherType that indicates the payload of an Ethernet frame contains an IPv6 (Internet Protocol version 6) packet.</p></blockquote>
<p><strong>EtherType in Ethernet Frames:</strong></p>
<p>In Ethernet networking, the EtherType field is a two-octet (16-bit) value within an Ethernet frame that specifies the protocol encapsulated in the payload. This field helps the receiving device determine how to process the incoming data.</p>
<p><strong>Significance of <code>0x86DD</code>:</strong></p>
<p>When the EtherType field is set to <code>0x86DD</code>, it signifies that the payload is an IPv6 packet. This designation is crucial for network devices to correctly interpret and route IPv6 traffic.</p>
<p><strong>Example Ethernet Frame Structure with IPv6:</strong></p>
<pre tabindex="0"><code>+-------------------+-------------------+-------------------+
| Destination MAC   | Source MAC        | EtherType = 0x86DD|
+-------------------+-------------------+-------------------+
| IPv6 Header and Payload                               |
+-------------------------------------------------------+
</code></pre><p>In this structure:</p>
<ul>
<li><strong>Destination MAC</strong>: The hardware address of the destination device.</li>
<li><strong>Source MAC</strong>: The hardware address of the source device.</li>
<li><strong>EtherType</strong>: <code>0x86DD</code>, indicating the payload is an IPv6 packet.</li>
<li><strong>IPv6 Header and Payload</strong>: The actual IPv6 data being transmitted.</li>
</ul>
<p><strong>Note:</strong></p>
<p>It&rsquo;s important to distinguish between EtherType values and IP protocol numbers. EtherType values, like <code>0x86DD</code>, are used in Ethernet frames to indicate the encapsulated protocol. In contrast, IP protocol numbers are used within the IP header to specify the next-level protocol (e.g., TCP, UDP).</p>
<p>For more detailed information, you can refer to the <a href="https://en.wikipedia.org/wiki/EtherType">EtherType Wikipedia page</a>.</p>
<p>[!NOTE]
When receiving packets from a <strong>TUN interface</strong> (or similar network tap), you may get both IPv4 and IPv6 packets, and <strong>you have to manually filter them</strong> based on your requirements. Here&rsquo;s why and how this works:</p>
<hr>
<h3 id="why-both-ipv4-and-ipv6-packets-are-received"><strong>Why Both IPv4 and IPv6 Packets Are Received</strong></h3>
<ol>
<li>
<p><strong>TUN Interface Behavior:</strong></p>
<ul>
<li>A TUN interface operates at the network (IP) layer and captures raw IP packets.</li>
<li>Since IPv4 and IPv6 are both network layer protocols, a TUN interface doesn&rsquo;t inherently differentiate between them—it passes everything it receives from the kernel&rsquo;s networking stack.</li>
</ul>
</li>
<li>
<p><strong>Mixed Traffic in Networks:</strong></p>
<ul>
<li>Many networks support both IPv4 and IPv6 traffic simultaneously (dual-stack environments).</li>
<li>Without filtering, you might receive a mix of packets intended for both protocols, leading to unnecessary complexity if you&rsquo;re only interested in one.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="how-to-differentiate-ipv4-and-ipv6-packets"><strong>How to Differentiate IPv4 and IPv6 Packets</strong></h3>
<p>The <strong>protocol field</strong> in the packet header helps identify whether a packet is IPv4 or IPv6:</p>
<h4 id="ipv4-packets"><strong>IPv4 Packets:</strong></h4>
<ul>
<li>EtherType/Protocol Number: <code>0x0800</code> (decimal: 2048).</li>
</ul>
<h4 id="ipv6-packets"><strong>IPv6 Packets:</strong></h4>
<ul>
<li>EtherType/Protocol Number: <code>0x86DD</code> (decimal: 34525).</li>
</ul>
<hr>
<h3 id="manually-filtering-packets-in-your-code"><strong>Manually Filtering Packets in Your Code</strong></h3>
<p>You can use the <code>protocol</code> field from the packet&rsquo;s metadata to filter out unwanted packets.</p>
<h4 id="example-in-rust"><strong>Example in Rust:</strong></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> nbytes <span style="color:#f92672">=</span> nic.recv(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buf[<span style="color:#f92672">..</span>])<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Extract protocol field (bytes 2-3)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> proto <span style="color:#f92672">=</span> <span style="color:#66d9ef">u16</span>::from_be_bytes([buf[<span style="color:#ae81ff">2</span>], buf[<span style="color:#ae81ff">3</span>]]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check protocol type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">match</span> proto {
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0x0800</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Handle IPv4 packet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">eprintln!</span>(<span style="color:#e6db74">&#34;Skipping IPv4 packet&#34;</span>);
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0x86DD</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Handle IPv6 packet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">eprintln!</span>(<span style="color:#e6db74">&#34;Processing IPv6 packet: </span><span style="color:#e6db74">{:02x?}</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>buf[<span style="color:#ae81ff">4</span><span style="color:#f92672">..</span>nbytes]);
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Unknown protocol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">eprintln!</span>(<span style="color:#e6db74">&#34;Unknown protocol: </span><span style="color:#e6db74">{:x}</span><span style="color:#e6db74">&#34;</span>, proto);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="output"><strong>Output:</strong></h4>
<ul>
<li>IPv4 packets will be skipped with a message: <code>Skipping IPv4 packet</code>.</li>
<li>IPv6 packets will be processed further and logged.</li>
</ul>
<hr>
<h3 id="advantages-of-filtering"><strong>Advantages of Filtering:</strong></h3>
<ol>
<li>
<p><strong>Streamlining Data Processing:</strong></p>
<ul>
<li>By focusing only on the relevant protocol, you reduce the complexity of your packet analysis or handling logic.</li>
</ul>
</li>
<li>
<p><strong>Resource Optimization:</strong></p>
<ul>
<li>Ignoring unnecessary packets saves computational resources and improves performance, especially in high-traffic environments.</li>
</ul>
</li>
<li>
<p><strong>Focused Debugging/Analysis:</strong></p>
<ul>
<li>Isolating a specific protocol (e.g., IPv6) simplifies debugging and makes the data stream more manageable.</li>
</ul>
</li>
</ol>
<ul>
<li>we need to add a filter ipv4(<code>0x0800</code>) to the program:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> proto <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0x0800</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// no ipv4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<p>Now we need to encode the <code>ipv4</code> header to our rust code</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">match</span> etherparse::Ipv4HeaderSlice::from_slice(<span style="color:#f92672">&amp;</span>buf[<span style="color:#ae81ff">4</span><span style="color:#f92672">..</span>nbytes]) {
</span></span><span style="display:flex;"><span>    Ok(p) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        nbytes: the number of bytes read into buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        &amp;buf[..bytes]: a slice of the buffer containing only the received data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        {:x} : attempts to format the buffer slice as hexadecimal*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">eprintln!</span>(
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;read </span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> bytes (flags: </span><span style="color:#e6db74">{:x}</span><span style="color:#e6db74">, proto: </span><span style="color:#e6db74">{:x}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{:x?}</span><span style="color:#e6db74">)&#34;</span>,
</span></span><span style="display:flex;"><span>                    nbytes <span style="color:#f92672">-</span> <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>                    flags,
</span></span><span style="display:flex;"><span>                    proto,
</span></span><span style="display:flex;"><span>                    p
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Err(e) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">eprintln!</span>(<span style="color:#e6db74">&#34;ignoring weird packet </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, e)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>when ping <code>192.168.2.2</code> using <code>tun0</code>, we will get</p>
<pre tabindex="0"><code>read 84 bytes (flags: 0, proto: 800: Ipv4HeaderSlice { slice: [45, 0, 0, 54, ab, fa, 40, 0, 40, 1, 1f, ed, ac, 15, 0, 2, c0, a8, 2, 2]})
</code></pre><p>Lets parse and print out things we actually care about</p>
<p>add log when recieve ping</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> nbytes <span style="color:#f92672">=</span> nic.recv(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buf[<span style="color:#f92672">..</span>])<span style="color:#f92672">?</span>; <span style="color:#75715e">// Receives a packet from the interface(when a packet arrives), return #bytes copied into the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                              <span style="color:#75715e">//print!(&#34;======run till here 3=============\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * u16::from_be_bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * constructs a `u16` integer from a 2-element byte array interpreted in big-endian
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * (network) byte order. This means the most significant byte is at the first position
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * of the array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Parameters:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * `bytes`: a `[u8; 2] array representing the bytes in big-endian order
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Output
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * returns a `u16` integer composed from the provided byte array*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// the first 4 bytes of the buffer ar einterpreted as metadata
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// enthernet frame we got,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// link level protocal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> _eth_flags <span style="color:#f92672">=</span> <span style="color:#66d9ef">u16</span>::from_be_bytes([buf[<span style="color:#ae81ff">0</span>], buf[<span style="color:#ae81ff">1</span>]]); <span style="color:#75715e">// byte 0-1: represent flags (interpreted as a u16 integer in big-endian order)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> eth_proto <span style="color:#f92672">=</span> <span style="color:#66d9ef">u16</span>::from_be_bytes([buf[<span style="color:#ae81ff">2</span>], buf[<span style="color:#ae81ff">3</span>]]); <span style="color:#75715e">// protocol type (e.g. IPv4, IPv6)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// filter anything that is not ipv4 packet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> eth_proto <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0x0800</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// no ipv4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> etherparse::Ipv4HeaderSlice::from_slice(<span style="color:#f92672">&amp;</span>buf[<span style="color:#ae81ff">4</span><span style="color:#f92672">..</span>nbytes]) {
</span></span><span style="display:flex;"><span>            Ok(p) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// nbytes: the number of bytes read into buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// &amp;buf[..nbytes] : a slice of the buffer containing only the received data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// {:x} : attempts to format the buffer slice as hexadecimal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">//print!(&#34;======run till here 4=============\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// NOTE: get proto type : 86dd , which is the enthertype that indicates the payload of an
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// enthernet frame contains an IPV6 (internet protocol version 6) packet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// ip level protocal, should be set to tcp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">let</span> src <span style="color:#f92672">=</span> p.source_addr();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> destination <span style="color:#f92672">=</span> p.destination_addr();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> protocal <span style="color:#f92672">=</span> p.protocol();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">eprintln!</span>(
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> -&gt; </span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">b of proto: </span><span style="color:#e6db74">{:x}</span><span style="color:#e6db74">  &#34;</span>,
</span></span><span style="display:flex;"><span>                    src,
</span></span><span style="display:flex;"><span>                    destination,
</span></span><span style="display:flex;"><span>                    p.payload_len(),
</span></span><span style="display:flex;"><span>                    protocal,
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Err(e) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">eprintln!</span>(<span style="color:#e6db74">&#34;ignoring weird packet </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, e)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>and I got</p>
<pre tabindex="0"><code>192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
192.168.2.1 -&gt; 192.168.2.2 64b of proto: 1
</code></pre><p>run <code>ip addr show tun0</code>, get</p>
<pre tabindex="0"><code>root@61cbf190478a:/home/developer/tcp_implementation# ip addr show tun0
33: tun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 500
    link/none
    inet 192.168.2.1/24 scope global tun0
       valid_lft forever preferred_lft forever
    inet6 fe80::cc61:19f0:9760:9006/64 scope link stable-privacy
       valid_lft forever preferred_lft forever
</code></pre><p>the tun0 interface is configured correctly and active (state UP). The IP address 192.168.2.1/24 is assigned, and is in the UP state.  The interface is ready to handle both IPv4 and IPv6 traffic.</p>
<ul>
<li>assign an IPv4 Address to <code>tun0</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip addr add 192.168.2.1/24 dev tun0
</span></span><span style="display:flex;"><span>sudo ip link set dev tun0 up
</span></span></code></pre></div><ul>
<li>
<p>ensure proper routing</p>
<ul>
<li>add a route for the IPv4 subnet:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip route add 192.168.2.0/24 dev tun0
</span></span></code></pre></div></li>
</ul>
<p>When your program prints <code>Packet captured on tun0: protocol 1, length 88</code>, it indicates that a packet with protocol number <code>1</code> and a total length of <code>88</code> bytes was captured on the <code>tun0</code> interface.</p>
<p><strong>Understanding Protocol Number 1:</strong></p>
<p>In the IPv4 header, the &ldquo;Protocol&rdquo; field specifies the next-level protocol used in the data portion of the packet. The protocol number <code>1</code> corresponds to the Internet Control Message Protocol (ICMP). ICMP is primarily used for diagnostic or control purposes, such as the <code>ping</code> command, which sends ICMP Echo Request messages to test network connectivity.</p>
<p><strong>Why is the Protocol Number Displayed as 1?</strong></p>
<p>The protocol number is displayed as <code>1</code> because your program is likely printing the decimal value of the &ldquo;Protocol&rdquo; field from the IPv4 header. In the IPv4 header, protocol numbers are represented as 8-bit integers. While these numbers can be expressed in hexadecimal (base 16), they are often displayed in decimal (base 10) for readability. In this case, the decimal value <code>1</code> corresponds to the hexadecimal value <code>0x01</code>, both representing ICMP.</p>
<p><strong>Interpreting the Packet Length:</strong></p>
<p>The length <code>88</code> indicates the total size of the captured packet in bytes. This includes the IPv4 header, the ICMP header, and any additional data payload. An ICMP Echo Request (commonly used by <code>ping</code>) typically consists of:</p>
<ul>
<li><strong>IPv4 Header:</strong> Usually 20 bytes.</li>
<li><strong>ICMP Header:</strong> 8 bytes.</li>
<li><strong>Data Payload:</strong> Variable length; in this case, approximately 60 bytes to reach a total packet size of 88 bytes.</li>
</ul>
<p><strong>Conclusion:</strong></p>
<p>The message <code>Packet captured on tun0: protocol 1, length 88</code> signifies that your program has intercepted an ICMP packet of 88 bytes on the <code>tun0</code> interface. This is typical behavior when tools like <code>ping</code> are used, as they generate ICMP traffic to test network connectivity.</p>
<p>For a comprehensive list of IP protocol numbers and their corresponding protocols, you can refer to the <a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">IANA Protocol Numbers</a>.</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
