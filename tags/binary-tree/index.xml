<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Binary Tree on davidgao7 blog</title>
    <link>http://localhost:1313/tags/binary-tree/</link>
    <description>Recent content in Binary Tree on davidgao7 blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 16 Feb 2025 17:02:01 -0500</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/binary-tree/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Symmetric Tree</title>
      <link>http://localhost:1313/posts/symmetric-tree/</link>
      <pubDate>Sun, 16 Feb 2025 17:02:01 -0500</pubDate>
      <guid>http://localhost:1313/posts/symmetric-tree/</guid>
      <description>&lt;h2 id=&#34;question-description&#34;&gt;Question Description&lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).&lt;/p&gt;&#xA;&lt;p&gt;Example 1:&lt;/p&gt;&#xA;&lt;p&gt;Input: root = [1,2,2,3,4,4,3]&#xA;Output: true&lt;/p&gt;&#xA;&lt;p&gt;Example 2:&lt;/p&gt;&#xA;&lt;p&gt;Input: root = [1,2,2,null,3,null,3]&#xA;Output: false&lt;/p&gt;&#xA;&lt;p&gt;Constraints:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;The number of nodes in the tree is in the range [ [1, 1000] ].&#xA;-100 &amp;lt;= Node.val &amp;lt;= 100&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;Follow up: Could you solve it both recursively and iteratively?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Binary Tree Path Sum</title>
      <link>http://localhost:1313/posts/binary-tree-path-sum/</link>
      <pubDate>Fri, 07 Feb 2025 22:29:31 -0500</pubDate>
      <guid>http://localhost:1313/posts/binary-tree-path-sum/</guid>
      <description>&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;&#xA;&lt;p&gt;给定一个节点数为 n 的二叉树和一个值 sum ，请找出所有的根节点到叶子节点的节点值之和等于的路径，如果没有则返回空。&lt;/p&gt;&#xA;&lt;p&gt;例如：&#xA;给出如下的二叉树，sum = 22 ，&lt;/p&gt;&#xA;&lt;p&gt;given:&#xA;&lt;img src=&#34;http://localhost:1313/images/pathSumEg.png&#34; alt=&#34;binary tree&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;return&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[&#xA;  [5,4,11,2],&#xA;  [5,8,9]&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;Space complexity: O(n)&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;Time complexity: O(n)&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;解题思路&#34;&gt;解题思路&lt;/h2&gt;&#xA;&lt;p&gt;题目是想让你一条一条路径找到和为sum的路径们，那我们学过的bfs(breath first search) 和 dfs(depth first search) 趁现在来复习一下&lt;/p&gt;&#xA;&lt;p&gt;Here&amp;rsquo;s the definition of BFS (ch 22.2 Introduction to Algorithms):&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Given a graph G = (V,E) and a distinguished &lt;strong&gt;source&lt;/strong&gt; vertex s, breadth-first search systematically explores the edges of G to &amp;lsquo;discover&amp;rsquo; every vertex that is &lt;strong&gt;reachable&lt;/strong&gt; from s.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lowest Common Ancestor</title>
      <link>http://localhost:1313/posts/lowest-common-ancestor/</link>
      <pubDate>Fri, 07 Feb 2025 20:54:23 -0500</pubDate>
      <guid>http://localhost:1313/posts/lowest-common-ancestor/</guid>
      <description>&lt;!-- 感想 --&gt;&#xA;&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;&#xA;&lt;p&gt;给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。&#xA;注：本题保证二叉树中每个节点的val值均不相同。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;e.g.&#xA;输入：[3,5,1,6,2,0,8,#,#,7,4],5,1&#xA;输出：3&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;题目思路&#34;&gt;题目思路&lt;/h2&gt;&#xA;&lt;p&gt;做这道题首先得理解潜在意思：两个节点的最近公共祖先&lt;/p&gt;&#xA;&lt;p&gt;题目要求查找的两个节点为&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5&lt;/li&gt;&#xA;&lt;li&gt;1&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;从图上我们可以知道距离5，1上方最近的是3，也就是说Node 5 与 Node 3 的common ancestor是3&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;怎样能首先检查 child， 然后再检查 parent 呢？&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;font color=red&gt;&lt;code&gt;L(child) R(child) N(parent)： Post order&lt;/code&gt;&lt;/font&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# bottom up lookup&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# post order : L R N&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# common ancestor: node.left=o1 and node.right=o2 or inverse&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# we can check L=o1,R=o2, then take the Node N using post order traversal&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# base case&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 如果在root找到o1 or o2 or null, 说明此时root为祖先&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; root &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; o1 &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; o2:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; root&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 左右subtree两个方向一起找,看看在左subtree还是右subtree&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;helper(root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left, o1, o2)  &lt;span style=&#34;color:#75715e&#34;&gt;# L&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;helper(root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right, o1, o2)  &lt;span style=&#34;color:#75715e&#34;&gt;# R&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 如果其中一边有，recursive的值要通过非Null的来返回，所以return非Null值&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# NOTE：not left &amp;lt;===&amp;gt; left == None&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; left: &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; right&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; right: &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; left&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#         if left == None: return right&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#         if right == None: return left&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 如果都没有，就返回啥都没有&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# elif not left and not right: 这代表两个都是空，说明没做到，本身就是空的，return就行&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; root&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>BinaryTree Output Levely</title>
      <link>http://localhost:1313/posts/binarytree-output-levely/</link>
      <pubDate>Fri, 07 Feb 2025 20:47:06 -0500</pubDate>
      <guid>http://localhost:1313/posts/binarytree-output-levely/</guid>
      <description>&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;&#xA;&lt;p&gt;给你一个二叉树，要求一层一层get这个二叉树的层序遍历的结果&lt;/p&gt;&#xA;&lt;p&gt;e.g. Given binary tree: {3,9,20,#,#,15,7}， 在code里是OOP的Tree来写的&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;T &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TreeNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TreeNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TreeNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TreeNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TreeNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;in order traversal result:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[&#xA;  [3],&#xA;  [9, 20],&#xA;  [15, 7]&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意TreeNode的定义，没有child的情况child为&lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;题目思路&#34;&gt;题目思路&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无论何时都得照顾好base case&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果给的tree结构里一个node也没有，我们不用担心什么，直接return 空[]&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;levelOrder&lt;/span&gt;(self, root):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; root:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; []&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;li&gt;之后， 我们用python list.pop(index=)来拿到我们想要的current node。 注意一下 &lt;strong&gt;pop()&lt;/strong&gt; 和 &lt;strong&gt;pop(0)&lt;/strong&gt; 的区别&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;pop()&lt;/strong&gt; 是取list中最后一个元素&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;pop(0)&lt;/strong&gt; 是取list中1st元素&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2,3]&#xA;&amp;gt;&amp;gt;&amp;gt; print(a.pop())&#xA;3&#xA;&amp;gt;&amp;gt;&amp;gt; print(a.pop(0))&#xA;1&#xA;&amp;gt;&amp;gt;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;font color=green&gt;Note: &lt;/font&gt;&#xA;平时用不太熟悉的语言时遇到不确定的语法可以到terminal上玩一下当作测试，也节省了上网查找浪费的时间&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;注意append node的顺序，我们首先append left child 然后 right child， 因为我们是被要求一层一层从左到右存放的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; curnode&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left: queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(curnode&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; curnode&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right: queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(curnode&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个过程是在遍历时先去左边的树再去右边的。按照题目规定&lt;strong&gt;每层&lt;/strong&gt;print时要从左往右储存。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
