<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on davidgao7 blog</title>
    <link>http://localhost:1313/tags/leetcode/</link>
    <description>Recent content in LeetCode on davidgao7 blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 03 May 2025 18:38:09 -0400</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Palindrome Linked List</title>
      <link>http://localhost:1313/posts/palindrome-linked-list/</link>
      <pubDate>Sat, 03 May 2025 18:38:09 -0400</pubDate>
      <guid>http://localhost:1313/posts/palindrome-linked-list/</guid>
      <description>&lt;h1 id=&#34;234-palindrome-linked-list&#34;&gt;234-palindrome-linked-list&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Date created: 2025-05-03-Sat 18:39&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;question-description&#34;&gt;Question Description&lt;/h2&gt;&#xA;&lt;p&gt;Given the head of a singly linked list, return true if it is a&lt;/p&gt;&#xA;&lt;p&gt;or false otherwise.&lt;/p&gt;&#xA;&lt;p&gt;Example 1:&lt;/p&gt;&#xA;&lt;p&gt;Input: head = [1,2,2,1]&#xA;Output: true&lt;/p&gt;&#xA;&lt;p&gt;Example 2:&lt;/p&gt;&#xA;&lt;p&gt;Input: head = [1,2]&#xA;Output: false&lt;/p&gt;&#xA;&lt;p&gt;Constraints:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;The number of nodes in the list is in the range [1, 105].&#xA;0 &amp;lt;= Node.val &amp;lt;= 9&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Follow up: Could you do it in O(n) time and O(1) space?&#xA;Seen this question in a real interview before?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Valid Word Abbreviation</title>
      <link>http://localhost:1313/posts/valid-word-abbr/</link>
      <pubDate>Wed, 12 Mar 2025 22:47:23 -0400</pubDate>
      <guid>http://localhost:1313/posts/valid-word-abbr/</guid>
      <description>&lt;h1 id=&#34;9197bbc079a9-valid-word-abbr&#34;&gt;9197bbc079a9-valid-word-abbr&lt;/h1&gt;&#xA;&lt;h3 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h3&gt;&#xA;&lt;p&gt;A string can be abbreviated by replacing any number of non-adjacent, non-empty substrings with their lengths. The lengths should not have leading zeros.&lt;/p&gt;&#xA;&lt;p&gt;For example, a string such as &lt;code&gt;&amp;quot;substitution&amp;quot;&lt;/code&gt; could be abbreviated as (but not limited to):&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;&amp;quot;s10n&amp;quot;&lt;/code&gt; (&lt;code&gt;&amp;quot;s ubstitutio n&amp;quot;&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;&amp;quot;sub4u4&amp;quot;&lt;/code&gt; (&lt;code&gt;&amp;quot;sub stit u tion&amp;quot;&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;&amp;quot;12&amp;quot;&lt;/code&gt; (&lt;code&gt;&amp;quot;substitution&amp;quot;&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;&amp;quot;su3i1u2on&amp;quot;&lt;/code&gt; (&lt;code&gt;&amp;quot;su bst i t u ti on&amp;quot;&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;&amp;quot;substitution&amp;quot;&lt;/code&gt; (no substrings replaced)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;The following are &lt;strong&gt;not valid&lt;/strong&gt; abbreviations:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Symmetric Tree</title>
      <link>http://localhost:1313/posts/symmetric-tree/</link>
      <pubDate>Sun, 16 Feb 2025 17:02:01 -0500</pubDate>
      <guid>http://localhost:1313/posts/symmetric-tree/</guid>
      <description>&lt;h2 id=&#34;question-description&#34;&gt;Question Description&lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).&lt;/p&gt;&#xA;&lt;p&gt;Example 1:&lt;/p&gt;&#xA;&lt;p&gt;Input: root = [1,2,2,3,4,4,3]&#xA;Output: true&lt;/p&gt;&#xA;&lt;p&gt;Example 2:&lt;/p&gt;&#xA;&lt;p&gt;Input: root = [1,2,2,null,3,null,3]&#xA;Output: false&lt;/p&gt;&#xA;&lt;p&gt;Constraints:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;The number of nodes in the tree is in the range [ [1, 1000] ].&#xA;-100 &amp;lt;= Node.val &amp;lt;= 100&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;Follow up: Could you solve it both recursively and iteratively?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lowest Common Ancestor</title>
      <link>http://localhost:1313/posts/lowest-common-ancestor/</link>
      <pubDate>Fri, 07 Feb 2025 20:54:23 -0500</pubDate>
      <guid>http://localhost:1313/posts/lowest-common-ancestor/</guid>
      <description>&lt;!-- 感想 --&gt;&#xA;&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;&#xA;&lt;p&gt;给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。&#xA;注：本题保证二叉树中每个节点的val值均不相同。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;e.g.&#xA;输入：[3,5,1,6,2,0,8,#,#,7,4],5,1&#xA;输出：3&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;题目思路&#34;&gt;题目思路&lt;/h2&gt;&#xA;&lt;p&gt;做这道题首先得理解潜在意思：两个节点的最近公共祖先&lt;/p&gt;&#xA;&lt;p&gt;题目要求查找的两个节点为&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5&lt;/li&gt;&#xA;&lt;li&gt;1&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;从图上我们可以知道距离5，1上方最近的是3，也就是说Node 5 与 Node 3 的common ancestor是3&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;怎样能首先检查 child， 然后再检查 parent 呢？&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;font color=red&gt;&lt;code&gt;L(child) R(child) N(parent)： Post order&lt;/code&gt;&lt;/font&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# bottom up lookup&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# post order : L R N&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# common ancestor: node.left=o1 and node.right=o2 or inverse&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# we can check L=o1,R=o2, then take the Node N using post order traversal&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# base case&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 如果在root找到o1 or o2 or null, 说明此时root为祖先&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; root &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; o1 &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; o2:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; root&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 左右subtree两个方向一起找,看看在左subtree还是右subtree&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;helper(root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left, o1, o2)  &lt;span style=&#34;color:#75715e&#34;&gt;# L&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;helper(root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right, o1, o2)  &lt;span style=&#34;color:#75715e&#34;&gt;# R&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 如果其中一边有，recursive的值要通过非Null的来返回，所以return非Null值&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# NOTE：not left &amp;lt;===&amp;gt; left == None&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; left: &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; right&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; right: &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; left&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#         if left == None: return right&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#         if right == None: return left&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 如果都没有，就返回啥都没有&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# elif not left and not right: 这代表两个都是空，说明没做到，本身就是空的，return就行&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; root&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>MaxLength</title>
      <link>http://localhost:1313/posts/maxlength/</link>
      <pubDate>Fri, 07 Feb 2025 20:52:49 -0500</pubDate>
      <guid>http://localhost:1313/posts/maxlength/</guid>
      <description>&lt;!-- 感想 --&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一步一个脚印，现在就是最艰难的时刻，不要懒，不要脸往前冲就行了&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;&#xA;&lt;p&gt;给定一个数组arr， 返回arr的&lt;em&gt;最长&lt;/em&gt; &lt;em&gt;无重复&lt;/em&gt; 子数组的长度，&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;e.g. 1&lt;/p&gt;&#xA;&lt;p&gt;a = [1, 3, 5, 7, 9]&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; sublist: [1, 3]&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; sublist: [3, 5, 7]&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; not a sublist: [1, 3, 7]&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;最长无重复子数组(maxLength)：[1, 3, 5, 7, 9]&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;e.g. 2&lt;/p&gt;&#xA;&lt;p&gt;a = [2, 2, 3, 4, 3]&lt;/p&gt;&#xA;&lt;p&gt;a_max = [2, 3, 4]&lt;/p&gt;&#xA;&lt;p&gt;maxLength = 3&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;题目思路&#34;&gt;题目思路&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一开始，我看到了&lt;code&gt;无重复&lt;/code&gt;，set不会有重复，但是set不能保证你拿的是连续的，不是连续的也就不能称之为sublist&lt;/li&gt;&#xA;&lt;li&gt;接着，我试了暴力解法，会超时，思路是双指针，右指针没有重复就右移， 有重复左指针向右移动一个防止漏掉前面的可能性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这个解法缺点是每一次指针移动都要检查答案是否可行，每一次检查又要loop从左指针到右指针，总共需要O(mn), polynomial time.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;首先要无重复， 那么我们一旦找到了重复的数字，由于需要return&lt;strong&gt;连续&lt;/strong&gt;的subarray，我们就只能去掉所有在第一个重复的数的后方的所有元素&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;找到无重复sublist：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; arr:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; l:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    l&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  l&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(i)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后我们在考虑怎样得到最长sublist：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Merge K Sorted Lists</title>
      <link>http://localhost:1313/posts/merge-k-sorted-lists/</link>
      <pubDate>Fri, 07 Feb 2025 20:49:10 -0500</pubDate>
      <guid>http://localhost:1313/posts/merge-k-sorted-lists/</guid>
      <description>&lt;!-- 感想 --&gt;&#xA;&lt;p&gt;就这一道题揪出了我的短板，虽然一直被强调什么语言都无所谓，能用就行，但是没有pointer我就不知道怎么更新了，这回有ptr的语言和没有的我都写，都好好理解一下，看看到底有什么“难处”！&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;这鬼题花了我两天时间！不好好整理一下（语言和思路）都对不起这时间！&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;为了补偿自己花费的更多时间，今天写两种方法&lt;/p&gt;&#xA;&lt;!-- 感想 --&gt;&#xA;&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;&#xA;&lt;p&gt;Given k sorted linked lists, combine them into a single linked list.&lt;/p&gt;&#xA;&lt;p&gt;Here&amp;rsquo;s an example:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Given&#xA;l1: 1 -&amp;gt; 2 -&amp;gt; 5&#xA;l2: 0 -&amp;gt; 8 -&amp;gt; 3&#xA;l3: 3 -&amp;gt; 4&#xA;&#xA;return&#xA;l: 0 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; 8&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;题目思路&#34;&gt;题目思路&lt;/h2&gt;&#xA;&lt;p&gt;Different from regular sorting problem, we are having linked lists, which are user&#xA;defined structure, we can&amp;rsquo;t have as much freedom as we did when we have the regular&#xA;data structure like arrays or lists.&#xA;We can expected that we will spend some time on thinking how we update element.&lt;/p&gt;</description>
    </item>
    <item>
      <title>BinaryTree Output Levely</title>
      <link>http://localhost:1313/posts/binarytree-output-levely/</link>
      <pubDate>Fri, 07 Feb 2025 20:47:06 -0500</pubDate>
      <guid>http://localhost:1313/posts/binarytree-output-levely/</guid>
      <description>&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;&#xA;&lt;p&gt;给你一个二叉树，要求一层一层get这个二叉树的层序遍历的结果&lt;/p&gt;&#xA;&lt;p&gt;e.g. Given binary tree: {3,9,20,#,#,15,7}， 在code里是OOP的Tree来写的&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;T &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TreeNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TreeNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TreeNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TreeNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TreeNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;in order traversal result:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[&#xA;  [3],&#xA;  [9, 20],&#xA;  [15, 7]&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意TreeNode的定义，没有child的情况child为&lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;题目思路&#34;&gt;题目思路&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无论何时都得照顾好base case&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果给的tree结构里一个node也没有，我们不用担心什么，直接return 空[]&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;levelOrder&lt;/span&gt;(self, root):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; root:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; []&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;li&gt;之后， 我们用python list.pop(index=)来拿到我们想要的current node。 注意一下 &lt;strong&gt;pop()&lt;/strong&gt; 和 &lt;strong&gt;pop(0)&lt;/strong&gt; 的区别&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;pop()&lt;/strong&gt; 是取list中最后一个元素&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;pop(0)&lt;/strong&gt; 是取list中1st元素&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2,3]&#xA;&amp;gt;&amp;gt;&amp;gt; print(a.pop())&#xA;3&#xA;&amp;gt;&amp;gt;&amp;gt; print(a.pop(0))&#xA;1&#xA;&amp;gt;&amp;gt;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;font color=green&gt;Note: &lt;/font&gt;&#xA;平时用不太熟悉的语言时遇到不确定的语法可以到terminal上玩一下当作测试，也节省了上网查找浪费的时间&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;注意append node的顺序，我们首先append left child 然后 right child， 因为我们是被要求一层一层从左到右存放的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; curnode&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left: queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(curnode&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; curnode&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right: queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(curnode&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个过程是在遍历时先去左边的树再去右边的。按照题目规定&lt;strong&gt;每层&lt;/strong&gt;print时要从左往右储存。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cout Vowel Strings</title>
      <link>http://localhost:1313/posts/cout-vowel-strings/</link>
      <pubDate>Fri, 07 Feb 2025 20:40:23 -0500</pubDate>
      <guid>http://localhost:1313/posts/cout-vowel-strings/</guid>
      <description>&lt;h1 id=&#34;统计字典序元音字符串的数目&#34;&gt;统计字典序元音字符串的数目&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;&#xA;&lt;p&gt;给你一个整数&lt;code&gt;n&lt;/code&gt;, 请返回长度为 &lt;code&gt;n&lt;/code&gt; ，仅由元音&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;e&lt;/code&gt;,&lt;code&gt;i&lt;/code&gt;,&lt;code&gt;o&lt;/code&gt;,&lt;code&gt;u&lt;/code&gt; 组成且按&lt;strong&gt;字典序&lt;/strong&gt;排列的字符串数量。&lt;/p&gt;&#xA;&lt;p&gt;字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：n = 1&#xA;输出：5&#xA;解释：仅由元音组成的 5 个字典序字符串为 [&amp;#34;a&amp;#34;,&amp;#34;e&amp;#34;,&amp;#34;i&amp;#34;,&amp;#34;o&amp;#34;,&amp;#34;u&amp;#34;]&#xA;&#xA;输入：n = 2&#xA;输出：15&#xA;解释：仅由元音组成的 15 个字典序字符串为&#xA;[&amp;#34;aa&amp;#34;,&amp;#34;ae&amp;#34;,&amp;#34;ai&amp;#34;,&amp;#34;ao&amp;#34;,&amp;#34;au&amp;#34;,&amp;#34;ee&amp;#34;,&amp;#34;ei&amp;#34;,&amp;#34;eo&amp;#34;,&amp;#34;eu&amp;#34;,&amp;#34;ii&amp;#34;,&amp;#34;io&amp;#34;,&amp;#34;iu&amp;#34;,&amp;#34;oo&amp;#34;,&amp;#34;ou&amp;#34;,&amp;#34;uu&amp;#34;]&#xA;注意，&amp;#34;ea&amp;#34; 不是符合题意的字符串，因为 &amp;#39;e&amp;#39; 在字母表中的位置比 &amp;#39;a&amp;#39; 靠后&#xA;&#xA;输入：n = 33&#xA;输出：66045&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;解法一-无脑数学&#34;&gt;解法一： 无脑数学&lt;/h2&gt;&#xA;&lt;p&gt;等价于把n个字母分给五种元音，且分配数目可以为零，就是求c(n+4, n) = c(n+4, 4)&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; countVowelStrings(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;解法二-动态规划&#34;&gt;解法二： 动态规划&lt;/h3&gt;&#xA;&lt;p&gt;a可以加在（aeiou）之前，e可以加在(eiou)之前，以此类推&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
